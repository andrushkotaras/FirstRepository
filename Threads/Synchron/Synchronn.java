package Threads.Synchron;

import java.util.concurrent.*;

public class Synchronn {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        // СИНХРОНІЗАТОРИ ПОТОКІВ

        countDownLatch(); // !!! Часто використовується

        cyclicBarrier(); // Рідко використовується

        semaphore(); // !!! Часто використовується






    }
     /* CyclicBarrier
       Це синхронізаційний допоміжник, який дозволяє групі потоків чекати один одного, щоб досягти спільної бар'єрної точки.

       Ініціалізація: Коли ви створюєте CyclicBarrier, ви вказуєте кількість потоків,
       які повинні досягти бар'єрної точки, перш ніж потоки можуть продовжити виконання.
       У нашому прикладі ми вказали 2, тому що у нас два потоки, які будуть досягати бар'єру.

       barrier.await();: Кожен потік викликає цей метод, коли досягає бар'єрної точки.
       Якщо потік є останнім, який досяг цієї точки (тобто лічильник потоків, які вже викликали await(),
       досягне значення, вказаного при ініціалізації), то всі чекаючі потоки будуть "випущені",
       і вони продовжать виконання. Якщо потік не є останнім, він буде заблокований до тих пір, поки інші потоки не досягнуть бар'єру.

       Додаткова дія: Ви також можете передати Runnable як другий аргумент при створенні CyclicBarrier.
        Цей Runnable буде виконаний, коли всі потоки досягнуть бар'єру, але перед тим, як вони будуть "випущені".
         У нашому прикладі це просто повідомлення, яке виводиться, коли обидва потоки досягли бар'єру.

       Основна відмінність між CountDownLatch та CyclicBarrier полягає в тому,
       що CyclicBarrier може бути використаний знову після того, як всі потоки досягли бар'єру,
       тоді як CountDownLatch може бути використаний лише один раз.

       Детальніше :
       CountDownLatch: Після того, як лічильник CountDownLatch досягає нуля,
       ви не можете "скинути" його або встановити лічильник знову на певне значення.
       Цей об'єкт стає непридатним для повторного використання. Якщо вам потрібно знову використовувати
       такий механізм, вам потрібно створити новий екземпляр CountDownLatch.

        CyclicBarrier: Після того, як всі потоки досягли бар'єру
        (тобто викликали await() відповідну кількість разів), CyclicBarrier "скидується" і
        може бути використаний знову. Це означає, що ті ж самі потоки (або інші потоки) можуть знову досягти бар'єру, і процес повторюється.

        Коли потік викликає barrier.await();, він не завершується. Замість цього:

        Лічильник CyclicBarrier зменшується на одиницю.
        Якщо лічильник ще не досягнув нуля, потік блокується і чекає, поки інші потоки також
        не викличуть barrier.await(); і лічильник не стане нулем.
        Якщо цей виклик barrier.await(); зменшує лічильник до нуля (тобто цей потік є останнім, який досяг бар'єру),
        тоді дві речі відбуваються:
        Якщо було передано Runnable при створенні CyclicBarrier, він виконується в цьому потоці.
        Після цього всі блоковані потоки "випускаються" і продовжують виконання після barrier.await();.
        Отже, потік, який викликає barrier.await();,
        блокується і чекає, поки всі інші потоки не досягнуть бар'єру.
        Він не завершується, а лише тимчасово призупиняється. Після того, як всі потоки досягли бар'єру, вони продовжують виконання.

        barrier.await();: Кожен потік, який викликає цей метод, блокується до тих пір,
         поки інші потоки також не викличуть await() відповідну кількість разів
         (яка була вказана при ініціалізації CyclicBarrier).
         Коли останній потік досягає бар'єру, всі блоковані потоки "випускаються" і продовжують виконання.
     */

    private static void cyclicBarrier(){
        CyclicBarrier cyclicBarrier = new CyclicBarrier(2,()->{
            System.out.println("barier"); // потоки повертаються сюди, коли обидва дойшли до барєру, після цього продовжують роботу після .await();
        });

        new Thread(()-> {
            System.out.println("to barier 1");
            try {
                cyclicBarrier.await();
            } catch (InterruptedException | BrokenBarrierException e){
                throw new RuntimeException(e);
            }

            System.out.println("after barier 1");
        }).start();

        new Thread(()-> {
            System.out.println("to barier 2");
            try {
                cyclicBarrier.await();
            } catch ( InterruptedException | BrokenBarrierException e){
                throw new RuntimeException(e);
            }

            System.out.println("after barier 2");
        }).start();

    }

     /*
        CountDownLatch
        Це синхронізаційний допоміжник, який дозволяє одному або декільком потокам чекати,
        поки інші потоки не завершать певні операції.

        latch.countDown(); - цей метод зменшує лічильник на одиницю.
         Коли лічильник досягає нуля, всі потоки, які чекають на latch.await(), продовжують виконання.

        latch.await(); - цей метод блокує потік, в якому він викликаний,
        доки лічильник CountDownLatch не стане нулем. Якщо лічильник вже нульовий, цей метод негайно повертається.

        У нашому прикладі ми створюємо CountDownLatch з лічильником 2.
        Це означає, що будь-який потік, який викликає latch.await(), буде заблокований, поки лічильник не стане нулем.

        Ми створюємо два потоки, і кожен з них викликає latch.countDown();
        після завершення своєї роботи. Таким чином, після того як обидва потоки завершать роботу,
        лічильник стане нулем, і будь-який потік, який чекає на latch.await(), продовжить виконання.

        latch.countDown();: Зменшує лічильник на одиницю. Потік, який викликає цей метод, не блокується і продовжує виконання наступного рядка коду.
        latch.await();: Блокує потік, поки лічильник latch не стане нулем. Тільки після цього потік, який викликав await(), продовжить виконання.
     */

    private static void countDownLatch() {
        CountDownLatch latch = new CountDownLatch(2);

        new Thread(()->{
            System.out.println("1");
            latch.countDown();
        }).start();

        new Thread(()-> {
            System.out.println("2");
            latch.countDown();
        }).start();

        try {
            latch.await();
        } catch (InterruptedException e){
            throw new RuntimeException(e);
        }
        System.out.println("Both tasks are done");
    }

    /*
    Semaphore
    Семафор контролює доступ до ресурсу за допомогою лічильника.
     Якщо лічильник більший за нуль, доступ дозволено; якщо він нульовий, доступ заборонено.

     Semaphore - це синхронізаційний механізм, який контролює доступ до обмеженого ресурсу.
     Він має внутрішній лічильник, який відображає кількість доступних "дозволів" (або "ліцензій").

     Ініціалізація: Коли ви створюєте Semaphore, ви вказуєте початкову кількість доступних дозволів.
     Це не обов'язково кількість потоків, але в багатьох сценаріях це може відповідати максимальній кількості потоків,
      які можуть одночасно використовувати ресурс.

     semaphore.acquire();: Коли потік викликає цей метод, він намагається отримати дозвіл.
     Якщо дозвіл доступний (тобто лічильник більший за 0), лічильник зменшується на одиницю, і потік продовжує виконання.
     Якщо дозволів немає (лічильник рівний 0), потік блокується і чекає, поки інший потік не відпустить дозвіл.

     semaphore.release();: Коли потік викликає цей метод, він "відпускає" дозвіл, збільшуючи лічильник на одиницю.
     Якщо існують інші потоки, які чекають на дозвіл (тобто були заблоковані на acquire()), один з них "випускається" і може продовжити виконання.
     */

    private static void semaphore() {
        Semaphore semaphore = new Semaphore(1);

        new Thread(()->{

            try {
                semaphore.acquire();
                System.out.println("do 1");
                Thread.sleep(2000);
            } catch (InterruptedException e){
                e.printStackTrace();
            } finally {
                semaphore.release();
            }
        }).start();

        new Thread(()->{

            try {
                semaphore.acquire();
                System.out.println("do 2");
                Thread.sleep(2000);
            } catch (InterruptedException e){
                throw new RuntimeException(e);
            } finally {
                semaphore.release();
            }
        }).start();
    }

    /*
        відмінності від synchronized / volatile

        Відмінності між volatile, synchronized та синхронізаторами, такими як CountDownLatch, CyclicBarrier та Semaphore, полягають у їх призначенні
        та способах використання. (Зазвичай між потоками їх прокидують або через конструктор, або через сеттер, а ініціалізують у головному класі)

        volatile:

        volatile - це модифікатор змінної, який гарантує, що зміни, внесені одним потоком, будуть видимі іншим потокам негайно.
        Він використовується для забезпечення видимості змінних між потоками.
        volatile не може гарантувати атомарності складних операцій.
        synchronized:

        synchronized блокує доступ до певного ресурсу або блоку коду для одного потоку в один момент часу.
        Він використовується для забезпечення взаємного виключення, коли потрібно виконувати критичний розділ коду.
        synchronized також забезпечує видимість змінних між потоками, але він "важчий" за volatile, оскільки він вводить блокування.
        Синхронізатори (CountDownLatch, CyclicBarrier, Semaphore):

        Ці інструменти використовуються для координації роботи між декількома потоками.
        Вони не блокують код або змінні напряму, як synchronized. Замість цього вони дозволяють потокам чекати один
        одного або обмежувати доступ до ресурсів.
        Вони дуже гнучкі та можуть використовуватися для різних сценаріїв координації.
        Висновок:

        Якщо вам потрібно забезпечити лише видимість змінної між потоками, використовуйте volatile.
        Якщо вам потрібно забезпечити взаємне виключення при доступі до критичного розділу коду, використовуйте synchronized.
        Якщо вам потрібно координувати роботу між декількома потоками, використовуйте відповідний синхронізатор
        (CountDownLatch, CyclicBarrier, Semaphore).
        Синхронізатори не "менш блокують" за synchronized.
        Вони просто пропонують різні механізми для координації потоків, залежно від конкретних потреб.
     */
}